## JavaScript学习笔记 异步

---

### 1. js中异步方式

javascript是单线程事件循环模型。

同步：顺序执行代码，每一步都会阻塞下一步

异步：执行异步代码，不必等待返回（不阻塞），继续执行下一步（console.log也是异步的）

异步与并行的区别：异步是 关于**现在**和**将来**的时间间隙，而并行是关于能够**同时发生**的事情

并行和并发的区别：并行是关于能够**同时发生**的事情，并发是在一段时间内同时执行的事情

并行问题（线程安全问题）：

**如果存在并行，当并行的两个方法同时修改公共变量，就会造成意外结果，出现不确定性。但是在js的单线程模式中，只有并发，没有并行，每个方法都是原子性的，则方法都是线程安全的。**

### 2. js以往的异步方式

+ 回调方式

  回调方式是在未来某个时刻，将回调函数加入到事件循环中，等待执行。
  
  串联多个异步操作的时候，通常需要**深度嵌套回调函数**（**回调地域**）



### 3. 异步的原理

+ 事件循环

  定时器、网络请求等等回调方式，当在得到结果的时候，将回调函数加入到事件队列里。等到事件循环执行到该回调函数的时候执行。（不能保证加入到队列的顺序）
  
+ 任务队列

  它是挂在事件循环队列的每个 tick 之后的一个队列。在事件循环的每个 tick 中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中，而会在**当前** tick 的任务队列末尾添加一个项目（一个任务）。

事件循环队列类似于一个游乐园游戏：玩过了一个游戏之后，你需要重新到队尾排队才能 再玩一次。而任务队列类似于玩过了游戏之后，插队接着继续玩。

### 3. Promise

普通的回调方式，是把自己的处理程序穿给第三方，控制器在第三方。而Promise，则是由第三方传回状态，由自己控制处理。

Promise类似，点餐给号系统，只是通知餐点做好了，如何处理这个餐点由顾客后续处理。

+ 创建一个Promise：

  ```
  let a = new Promise((res,rej)=>{
  	console.log("a")
  	res("a");
  });
  a.then((res)=>{
  	console.log("1")
  })
  
  a.then((res)=>{
  	console.log("2")
  })
  
  a.catch((err)=>{
  	//只会捕捉a创建的时候，以及resolve过程中的错误
  	//不会捕捉then过程中的，因为then返回的是另一个promise
  	console.log("err")
  })
  //其中Promise传入的方法会被立即执行，则其中的的console.log("a")会被立即执行（同步执行）
  //而then则会在事件循环的下一个事件之前执行
  //同一个promise下的不同then，按照注册顺序执行
  
  //在 Promise 的创建过程中或在查看其resolve结果过程中的任何时间点上出现了一个 JavaScript 异常错误，比如一个 TypeError 或ReferenceError，那这个异常就会被捕捉，并且会使这个 Promise 被拒绝
  ```

+ Promise.resovle(v)

  改方法总会返回一个promise，如果v是一个promise则展开（展开过程会持续到提取出一个具体的非类 Promise 的最终值），如果v是一个立即值，则为一个promise，且resolve这个立即值。主要用于将同步和异步promise都创建为一个promise来处理。

  ```
  let a = "1";
  let b = new Promise((res,rej)=>{
  	res("b");
  });
  
  Promise.resolve(a).then(res=>{
  	console.log(res) //1
  })
  Promise.resolve(b).then(res=>{
  	console.log(res) //b
  })
  ```

  



---

#### [返回目录](./)