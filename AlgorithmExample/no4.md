## 算法例题学习笔记 动态规划

---

#### 1. 最长回文子串（返回子串）(5)

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

思路：

1. 暴力求解，列举所有的子串，判断是否为回文串，保存最长的回文串。（判断回文可以用动态规划 P(i,j)表示从i到j的子字符串是否为回文）
2. 最长公共子串，找正序和反序字符串的公共子串，求最长公共子串（不是公共子序列），判断该字符串倒置前的下标和当前的字符串下标是不是匹配。

#### 2. 判断字符串是否为回文字符串（动态规划）

用 P*(*i*,*j) 表示字符串 s 的第 i到 j 个字母组成的串（下文表示成 s[i:j]）是否为回文串

*P*(*i*,*j*)=*P*(*i*+1,*j*−1)∧(*S**i*==*S**j*)

边界条件：即子串的长度为 1 或 2。对于长度为 1的子串，它显然是个回文串；对于长度为 2 的子串，只要它的两个字母相同，它就是一个回文串

*P*(*i*,*i*)=true

*P*(*i*,*i*+1)=(*S**i*==*S**i*+1)

动态规划：

先处理边界条件，列举所有长度1和2的子串进行判断，然后遍历长度3到len的子串进行判断。

#### 3. 求最长公共子串（动态规划）

状态转移：c(i,j)表示，字符串a长度i，字符串b长度j的公共子串长度





---

#### [返回目录](./)

