## 算法学习笔记 双指针与滑动窗口

---

### 1. 滑动窗口算法

> 滑动窗口算法是在给定特定窗口大小的数组或字符串上执行要求的操作。
>
> 该技术可以将一部分问题中的嵌套循环转变为一个单循环，因此它可以减少时间复杂度。

简而言之，滑动窗口算法在一个特定大小的字符串或数组上进行操作，而不在整个字符串和数组上操作，这样就降低了问题的复杂度，从而也达到降低了循环的嵌套深度。**其实这里就可以看出来滑动窗口主要应用在数组和字符串上。**

可以用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题。由于区间连续，因此当区间发生变化时，可以通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度。**往往类似于“ 请找到满足 xx 的最 x 的区间（子串、子数组）的 xx ”这类问题都可以使用该方法进行解决。**

需要注意的是，滑动窗口算法更多的是一种思想，而非某种数据结构的使用。 

#### 滑动窗口法的大体框架

- **滑动：**说明这个窗口是移动的，也就是移动是按照一定方向来的。
- **窗口：**窗口大小并不是固定的，可以不断扩容直到满足一定的条件；也可以不断缩小，直到找到一个满足条件的最小窗口；当然也可以是固定大小。

采用的是字符串来讲解。但是对于数组其实也是一样的。滑动窗口算法的思路是这样：

1. 我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。
2. 我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串(不)符合要求（包含了 T 中的所有字符）。
3. 此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串(不)符合要求。同时，每次增加 left，我们都要更新一轮结果。
4. 重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。

#### 1.1 无重复字符的最长子串 (3)

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

示例 1:

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

示例 2:

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

示例 3:

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

示例 4:

```
输入: s = ""
输出: 0
```

```
/**
 * @param {string} s
 * @return {number}
 */
let lengthOfLongestSubstring = function(s) {
    const set = new Set(); // hash set保存是否包含某个字符
    let left = 0; // 左边界
    let right = 0; // 右边界
    let max = 0; // 最大长度

    for(;right<s.length;right++){
        if(!set.has(s.charAt(right))){
            //扩大窗口，更新最大长度
            set.add(s.charAt(right));
            max = Math.max(max, set.size);
        }
        else{
            //缩小窗口，直到再次满足条件
            while(set.has(s.charAt(right))){
                set.delete(s.charAt(left));
                left++;
            }
            set.add(s.charAt(right));
        }
    }
    return max;
};
```





---

#### [返回目录](./)